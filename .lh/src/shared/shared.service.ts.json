{
    "sourceFile": "src/shared/shared.service.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1751206197175,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1751206545658,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,8 +4,13 @@\n import { Application } from 'src/application/entities/application.entity';\r\n import { CreateKeyDto } from 'src/key/dto/create-key.dto';\r\n import { Key } from 'src/key/entities/key.entity';\r\n import { KeyType } from 'src/key/enum';\r\n+import {\r\n+  BadRequestErrorResponse,\r\n+  NotFoundErrorResponse,\r\n+} from 'src/model/error_response';\r\n+import { DataResponse } from 'src/model/success_response';\r\n import { Repository } from 'typeorm';\r\n import { v4 as uuidv4 } from 'uuid';\r\n \r\n @Injectable()\r\n@@ -16,9 +21,9 @@\n     @InjectRepository(Application)\r\n     private readonly appRepo: Repository<Application>,\r\n   ) {}\r\n \r\n-  private async generateKey(options: Partial<CreateKeyDto>): Promise<string> {\r\n+  async generateKey(options: Partial<CreateKeyDto>): Promise<string> {\r\n     const {\r\n       type,\r\n       length = 32,\r\n       prefix = '',\r\n@@ -98,5 +103,37 @@\n     }\r\n \r\n     return result;\r\n   }\r\n+\r\n+  async findApplicationById(\r\n+    id: string,\r\n+  ): Promise<\r\n+    DataResponse<Application> | NotFoundErrorResponse | BadRequestErrorResponse\r\n+  > {\r\n+    if (!id) {\r\n+      return new BadRequestErrorResponse('Application ID is required');\r\n+    }\r\n+\r\n+    try {\r\n+      const application = await this.appRepo.findOne({\r\n+        where: { id },\r\n+      });\r\n+\r\n+      if (!application) {\r\n+        return new NotFoundErrorResponse('Application not found');\r\n+      }\r\n+\r\n+      return new DataResponse<Application>(\r\n+        application,\r\n+        'Application found successfully',\r\n+        200,\r\n+      );\r\n+    } catch (error) {\r\n+      if (error.code === '23503') {\r\n+        // Foreign key violation error code\r\n+        return new NotFoundErrorResponse('Application not found');\r\n+      }\r\n+      return new BadRequestErrorResponse('An unexpected error occurred');\r\n+    }\r\n+  }\r\n }\r\n"
                },
                {
                    "date": 1751206554071,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -123,10 +123,10 @@\n         return new NotFoundErrorResponse('Application not found');\r\n       }\r\n \r\n       return new DataResponse<Application>(\r\n+        'Application found successfully',\r\n         application,\r\n-        'Application found successfully',\r\n         200,\r\n       );\r\n     } catch (error) {\r\n       if (error.code === '23503') {\r\n"
                },
                {
                    "date": 1751207978224,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -116,8 +116,9 @@\n \r\n     try {\r\n       const application = await this.appRepo.findOne({\r\n         where: { id },\r\n+        relations: ['keys'],\r\n       });\r\n \r\n       if (!application) {\r\n         return new NotFoundErrorResponse('Application not found');\r\n"
                }
            ],
            "date": 1751206197175,
            "name": "Commit-0",
            "content": "import { Injectable } from '@nestjs/common';\r\nimport { InjectRepository } from '@nestjs/typeorm';\r\nimport { randomBytes } from 'crypto';\r\nimport { Application } from 'src/application/entities/application.entity';\r\nimport { CreateKeyDto } from 'src/key/dto/create-key.dto';\r\nimport { Key } from 'src/key/entities/key.entity';\r\nimport { KeyType } from 'src/key/enum';\r\nimport { Repository } from 'typeorm';\r\nimport { v4 as uuidv4 } from 'uuid';\r\n\r\n@Injectable()\r\nexport class SharedService {\r\n  constructor(\r\n    @InjectRepository(Key)\r\n    private readonly keyRepo: Repository<Key>,\r\n    @InjectRepository(Application)\r\n    private readonly appRepo: Repository<Application>,\r\n  ) {}\r\n\r\n  private async generateKey(options: Partial<CreateKeyDto>): Promise<string> {\r\n    const {\r\n      type,\r\n      length = 32,\r\n      prefix = '',\r\n      suffix = '',\r\n      includeNumbers = true,\r\n      includeSymbols = false,\r\n      includeUppercase = true,\r\n      includeLowercase = true,\r\n    } = options;\r\n\r\n    switch (type) {\r\n      case KeyType.UUID:\r\n        return `${prefix}${uuidv4()}${suffix}`;\r\n\r\n      case KeyType.JWT_SECRET:\r\n        return this.generateSecureRandomString(64);\r\n\r\n      case KeyType.ENCRYPTION_KEY:\r\n        return randomBytes(32).toString('hex');\r\n\r\n      case KeyType.API_KEY:\r\n        const apiKey = this.generateCustomString(length, {\r\n          includeNumbers,\r\n          includeSymbols: false, // API keys typically don't include symbols\r\n          includeUppercase,\r\n          includeLowercase,\r\n        });\r\n        return `${prefix}${apiKey}${suffix}`;\r\n\r\n      case KeyType.RANDOM_TOKEN:\r\n        return randomBytes(length).toString('base64url');\r\n\r\n      case KeyType.CUSTOM:\r\n      default:\r\n        const customKey = this.generateCustomString(length, {\r\n          includeNumbers,\r\n          includeSymbols,\r\n          includeUppercase,\r\n          includeLowercase,\r\n        });\r\n        return `${prefix}${customKey}${suffix}`;\r\n    }\r\n  }\r\n\r\n  private generateSecureRandomString(length: number): string {\r\n    return randomBytes(Math.ceil(length / 2))\r\n      .toString('hex')\r\n      .slice(0, length);\r\n  }\r\n\r\n  private generateCustomString(\r\n    length: number,\r\n    options: {\r\n      includeNumbers: boolean;\r\n      includeSymbols: boolean;\r\n      includeUppercase: boolean;\r\n      includeLowercase: boolean;\r\n    },\r\n  ): string {\r\n    let charset = '';\r\n\r\n    if (options.includeLowercase) charset += 'abcdefghijklmnopqrstuvwxyz';\r\n    if (options.includeUppercase) charset += 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\r\n    if (options.includeNumbers) charset += '0123456789';\r\n    if (options.includeSymbols) charset += '!@#$%^&*()_+-=[]{}|;:,.<>?';\r\n\r\n    if (!charset) {\r\n      charset =\r\n        'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\r\n    }\r\n\r\n    let result = '';\r\n    const randomValues = randomBytes(length);\r\n\r\n    for (let i = 0; i < length; i++) {\r\n      result += charset[randomValues[i] % charset.length];\r\n    }\r\n\r\n    return result;\r\n  }\r\n}\r\n"
        }
    ]
}